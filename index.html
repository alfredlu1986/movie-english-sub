<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Movie English Sub / CSV / DOCX Viewer + Search + Directory</title>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <style>
    :root{--bg:#f6f7fb;--card:#ffffff;--ink:#0f172a;--muted:#64748b;--brand:#2563eb;--brand-2:#1d4ed8;--line:#e2e8f0}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .card{background:var(--card);border-radius:14px;box-shadow:0 10px 30px rgba(15,23,42,.06);padding:20px 22px}
    h1{font-size:20px;margin:0 0 8px}
    h2{font-size:16px;margin:0 0 8px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .grid{display:grid;gap:12px}
    @media(min-width:860px){.grid-3{grid-template-columns: 1.5fr 1fr 1fr}}
    label{display:block;font-weight:600;font-size:13px;margin:6px 0 4px}
    input,select,button{width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:14px}
    select{background:#fff}
    button{border:none;background:var(--brand);color:#fff;font-weight:700;cursor:pointer}
    button:hover{background:var(--brand-2)}
    .status{margin-top:10px;font-size:13px;color:var(--muted)}
    .status .error{color:#b91c1c;font-weight:700}
    .tools{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .tools > *{flex:1}
    .result{margin-top:16px;border-top:1px solid var(--line);padding-top:14px;overflow:auto}
    table{border-collapse:collapse;width:100%;font-size:14px}
    th,td{border:1px solid var(--line);padding:6px 8px;vertical-align:top}
    th{background:#f1f5f9}
    pre{white-space:pre-wrap;background:#0f172a;color:#e5e7eb;padding:8px;border-radius:8px;margin:0}
    code{background:#f1f5f9;padding:2px 4px;border-radius:6px}
    mark{padding:0 2px;border-radius:3px}
    .hint{font-size:12px;color:var(--muted)}
    .pill{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:999px;font-size:12px;color:#64748b}

    /* layout with directory panel */
    .layout{display:grid;gap:16px;margin-top:16px}
    @media(min-width:1024px){.layout{grid-template-columns: 320px 1fr}}

    /* tree panel */
    #treeStatus{font-size:12px;color:#64748b;margin:6px 0 0}
    .tree{max-height:70vh;overflow:auto;border:1px solid var(--line);border-radius:12px;padding:8px}
    .tree ul{list-style:none;margin:0;padding-left:14px}
    .tree li{margin:2px 0}
    .node{display:flex;align-items:center;gap:6px}
    .toggle{border:none;background:transparent;cursor:pointer;font-size:14px;line-height:1;padding:2px 4px}
    .toggle:focus{outline:2px solid #c7d2fe;border-radius:6px}
    .fname{cursor:pointer}
    .fname.file{color:#0ea5e9}
    .muted{color:#64748b}
    .hidden{display:none}
    .badge{font-size:10px;border:1px solid var(--line);border-radius:6px;padding:0 6px;color:#475569}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Movie English Sub / Words Viewer</h1>
      <p class="sub">æ”¯æ´ <strong>.srt / .csv / .docx</strong> çš„è®€å–ã€é—œéµå­—æœå°‹ï¼ˆé«˜äº®/éæ¿¾ï¼‰ï¼Œä¸¦æä¾› <strong>ç›®éŒ„å¼é»è®€</strong>ï¼ˆå·¦å´æ¨¹ç‹€ï¼‰ã€‚é è¨­ repoï¼š<span class="pill">alfredlu1986/movie-english-sub@main</span></p>

      <div class="grid grid-3">
        <div>
          <label>Owner</label>
          <input id="owner" value="alfredlu1986" />
        </div>
        <div>
          <label>Repo</label>
          <input id="repo" value="movie-english-sub" />
        </div>
        <div>
          <label>Branch</label>
          <input id="branch" value="main" />
        </div>
      </div>

      <div class="layout">
        <!-- ===== Directory panel ===== -->
        <div class="card">
          <h2>ç›®éŒ„ / æª”æ¡ˆç€è¦½</h2>
          <div class="tools">
            <input id="treePath" placeholder="å¾æ­¤è·¯å¾‘è¼‰å…¥ï¼ˆç•™ç©º=æ ¹ç›®éŒ„ï¼Œä¾‹å¦‚ 1999/ï¼‰" />
            <button id="treeLoad">è¼‰å…¥ç›®éŒ„</button>
          </div>

          <div class="tools">
            <input id="nameFilter" placeholder="æª”åå³æ™‚éæ¿¾ï¼ˆä¸åˆ†å¤§å°å¯«ï¼‰" />
          </div>

          <div class="tools">
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="showSRT" checked> .srt</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="showCSV" checked> .csv</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="showDOCX" checked> .docx</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="showOTHER"> å…¶ä»–å‰¯æª”å</label>
          </div>

          <div id="treeStatus"></div>
          <div id="tree" class="tree"><ul id="treeRoot"></ul></div>
        </div>

        <!-- ===== Viewer / search panel ===== -->
        <div class="card">
          <h2>æª”æ¡ˆæª¢è¦– & æœå°‹</h2>
          <div class="grid" style="gap:10px">
            <div>
              <label>æª”æ¡ˆè·¯å¾‘ï¼ˆç›¸å°æ–¼ repo rootï¼‰</label>
              <input id="path" placeholder="ä¾‹å¦‚ï¼šEnWords.csv æˆ– 1999/movie.srt æˆ– docs/sample.docx" />
            </div>
            <div>
              <label>æª”æ¡ˆé¡å‹</label>
              <select id="fileType">
                <option value="srt">SRT å­—å¹• (.srt)</option>
                <option value="csv">CSV (.csv)</option>
                <option value="docx">Word (.docx)</option>
              </select>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="loadBtn">è¼‰å…¥æª”æ¡ˆ</button>
            </div>
          </div>

          <div class="tools">
            <div style="flex:2">
              <label>é—œéµå­—æœå°‹</label>
              <input id="q" placeholder="è¼¸å…¥é—œéµå­—ï¼ŒEnter æœå°‹" />
              <div class="hint">SRT / CSV å¯é¸ã€Œåªé¡¯ç¤ºç¬¦åˆã€ï¼›DOCX ä»¥å…¨æ–‡é«˜äº®</div>
            </div>
            <div style="flex:2">
              <label>æœå°‹é¸é …</label>
              <div class="tools">
                <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="matchCase"> å¤§å°å¯«ç›¸ç¬¦</label>
                <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="wholeWord"> å…¨å­—æ¯”å°</label>
                <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="filterRows"> åªé¡¯ç¤ºç¬¦åˆï¼ˆSRT/CSVï¼‰</label>
              </div>
            </div>
            <div style="align-self:end;flex:1;display:flex;gap:10px">
              <button id="searchBtn">æœå°‹ / é«˜äº®</button>
              <button id="clearBtn" style="background:#334155">æ¸…é™¤</button>
            </div>
          </div>

          <div class="status" id="status"></div>
          <div class="status" id="counts"></div>
          <div class="result" id="result"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id)=>document.getElementById(id);

    const ownerEl = $("owner"), repoEl=$("repo"), branchEl=$("branch");
    const pathEl=$("path"), typeEl=$("fileType"), loadBtn=$("loadBtn");
    const qEl=$("q"), matchCaseEl=$("matchCase"), wholeWordEl=$("wholeWord"), filterRowsEl=$("filterRows");
    const searchBtn=$("searchBtn"), clearBtn=$("clearBtn");
    const statusEl=$("status"), countsEl=$("counts"), resultEl=$("result");

    const treeRoot = $("treeRoot"), treeStatus=$("treeStatus"), treeLoad=$("treeLoad"), treePathEl=$("treePath");
    const showSRT=$("showSRT"), showCSV=$("showCSV"), showDOCX=$("showDOCX"), showOTHER=$("showOTHER"), nameFilter=$("nameFilter");

    function rawBase(){
      const o = ownerEl.value.trim() || "alfredlu1986";
      const r = repoEl.value.trim() || "movie-english-sub";
      const b = branchEl.value.trim() || "main";
      return {o,r,b, url:`https://raw.githubusercontent.com/${o}/${r}/${b}/`};
    }
    function apiBase(){
      const o = ownerEl.value.trim() || "alfredlu1986";
      const r = repoEl.value.trim() || "movie-english-sub";
      const b = branchEl.value.trim() || "main";
      return {o,r,b, url:`https://api.github.com/repos/${o}/${r}/contents/`, ref:b};
    }
    function escapeHtml(str){
      return String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    }
    function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
    function buildRegex(query){
      if(!query) return null;
      const src = wholeWordEl.checked ? `\\b${escapeRegExp(query)}\\b` : escapeRegExp(query);
      return new RegExp(src, matchCaseEl.checked?"g":"gi");
    }
    function extOf(name){ const m = name.toLowerCase().match(/\.([a-z0-9]+)$/); return m?m[1]:""; }
    function showByExt(name){
      const ext = extOf(name);
      if(ext==='srt') return showSRT.checked;
      if(ext==='csv') return showCSV.checked;
      if(ext==='docx') return showDOCX.checked;
      return showOTHER.checked;
    }

    treeLoad.addEventListener('click', () => loadTree(treePathEl.value.trim()));
    ownerEl.addEventListener('change', ()=>loadTree(treePathEl.value.trim()));
    repoEl.addEventListener('change', ()=>loadTree(treePathEl.value.trim()));
    branchEl.addEventListener('change', ()=>loadTree(treePathEl.value.trim()));
    showSRT.addEventListener('change', ()=>applyTreeFilters());
    showCSV.addEventListener('change', ()=>applyTreeFilters());
    showDOCX.addEventListener('change', ()=>applyTreeFilters());
    showOTHER.addEventListener('change', ()=>applyTreeFilters());
    nameFilter.addEventListener('input', ()=>applyTreeFilters());

    async function loadTree(path=""){
      treeStatus.textContent = 'è®€å–ä¸­â€¦';
      treeRoot.innerHTML = '';
      try{
        const root = await fetchDir(path);
        const rootNode = renderDirNode(path || '/', root);
        treeRoot.appendChild(rootNode);
        treeStatus.textContent = 'å®Œæˆã€‚é»è³‡æ–™å¤¾å±•é–‹/æ”¶åˆï¼Œé»æª”æ¡ˆå³è¼‰å…¥æª¢è¦–ã€‚';
        applyTreeFilters();
      }catch(err){
        treeStatus.innerHTML = `<span class="error">è¼‰å…¥å¤±æ•—ï¼š${escapeHtml(err.message||String(err))}</span>`;
      }
    }

    async function fetchDir(path){
      const {url, ref} = apiBase();
      const api = url + encodeURIComponent(path).replace(/%2F/g,'/') + (path && path.endsWith('/')?'':'') + `?ref=${encodeURIComponent(ref)}`;
      const res = await fetch(api);
      if(!res.ok) throw new Error(`GitHub API ${res.status}`);
      const data = await res.json();
      if(!Array.isArray(data)) throw new Error('éç›®éŒ„ï¼ˆæˆ–è·¯å¾‘ä¸å­˜åœ¨ï¼‰');
      data.sort((a,b)=> (a.type===b.type? a.name.localeCompare(b.name) : (a.type==='dir'?-1:1)) );
      return data;
    }

    function renderDirNode(path, entries){
      const li = document.createElement('li');
      li.className = 'node dir';
      const display = path || '/';
      const header = document.createElement('div');
      header.className = 'node';
      const btn = document.createElement('button');
      btn.className = 'toggle';
      btn.textContent = 'â–¾';
      const span = document.createElement('span');
      span.className = 'fname';
      span.textContent = `ğŸ“ ${display}`;
      header.appendChild(btn); header.appendChild(span);
      li.appendChild(header);

      const ul = document.createElement('ul');
      ul.className = '';
      li.appendChild(ul);

      for(const ent of entries){
        if(ent.type==='dir') ul.appendChild(renderClosedFolder(ent.path));
        else ul.appendChild(renderFile(ent.path, ent.name));
      }

      let collapsed = false;
      btn.addEventListener('click', ()=>{
        collapsed = !collapsed;
        btn.textContent = collapsed ? 'â–¸' : 'â–¾';
        ul.classList.toggle('hidden', collapsed);
      });

      return li;
    }

    function renderClosedFolder(fullPath){
      const li = document.createElement('li');
      li.className='node dir';
      const head = document.createElement('div');
      head.className='node';
      const btn = document.createElement('button'); btn.className='toggle'; btn.textContent='â–¸';
      const span = document.createElement('span'); span.className='fname'; span.textContent='ğŸ“ '+fullPath.split('/').pop();
      head.appendChild(btn); head.appendChild(span); li.appendChild(head);
      const ul = document.createElement('ul'); ul.className='hidden'; li.appendChild(ul);

      let loaded = false; let collapsed = true;
      async function expand(){
        if(!loaded){
          try{
            const children = await fetchDir(fullPath);
            for(const ent of children){
              if(ent.type==='dir') ul.appendChild(renderClosedFolder(ent.path));
              else ul.appendChild(renderFile(ent.path, ent.name));
            }
            loaded = true;
            applyTreeFilters();
          }catch(err){
            const errLi = document.createElement('li');
            errLi.innerHTML = `<span class=\"muted\">ç„¡æ³•è®€å–ï¼š${escapeHtml(err.message||String(err))}</span>`;
            ul.appendChild(errLi);
          }
        }
        collapsed = false; btn.textContent='â–¾'; ul.classList.remove('hidden');
      }
      function collapse(){ collapsed = true; btn.textContent='â–¸'; ul.classList.add('hidden'); }

      btn.addEventListener('click', ()=>{ collapsed?expand():collapse(); });
      span.addEventListener('click', ()=>{ collapsed?expand():collapse(); });
      return li;
    }

    function renderFile(fullPath, name){
      const li = document.createElement('li');
      li.className='node file';
      li.dataset.fullPath = fullPath;
      const row = document.createElement('div'); row.className='node';
      const a = document.createElement('a'); a.href='#'; a.className='fname file'; a.textContent='ğŸ“„ '+name; a.title=fullPath;
      const badge = document.createElement('span'); badge.className='badge'; badge.textContent=extOf(name)||'file';
      row.appendChild(a); row.appendChild(badge); li.appendChild(row);
      a.addEventListener('click', (e)=>{ e.preventDefault(); openFileFromTree(fullPath, name); });
      return li;
    }

    function applyTreeFilters(){
      const q = nameFilter.value.trim().toLowerCase();
      const items = treeRoot.querySelectorAll('li.node.file');
      items.forEach(li=>{
        const name = li.querySelector('.fname').textContent.toLowerCase();
        const visibleExt = showByExt(name);
        const visibleName = !q || name.includes(q);
        li.style.display = (visibleExt && visibleName) ? '' : 'none';
      });
    }

    function openFileFromTree(fullPath, name){
      pathEl.value = fullPath;
      const ext = extOf(name);
      if(ext==='srt') typeEl.value='srt';
      else if(ext==='csv') typeEl.value='csv';
      else if(ext==='docx') typeEl.value='docx';
      else typeEl.value='srt';
      loadFile();
    }

    loadTree("");

    function highlightText(text, regex){
      if(!regex || !text) return escapeHtml(text);
      let out = ""; let lastIndex = 0; const s = String(text); let m;
      while((m = regex.exec(s))){
        out += escapeHtml(s.slice(lastIndex, m.index));
        out += `<mark>${escapeHtml(m[0])}</mark>`;
        lastIndex = m.index + m[0].length;
        if(!regex.global) break;
      }
      out += escapeHtml(s.slice(lastIndex));
      return out;
    }

    let lastType=null; let srtEntries=[]; let csvData={header:[],rows:[]}; let docxHtmlOriginal="";

    loadBtn.addEventListener('click', ()=>loadFile());
    qEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter') doSearch(); });
    searchBtn.addEventListener('click', ()=>doSearch());
    clearBtn.addEventListener('click', ()=>{ qEl.value=''; doSearch(); });

    async function loadFile(){
      const rel = pathEl.value.trim();
      if(!rel){ statusEl.innerHTML='<span class="error">è«‹è¼¸å…¥æª”æ¡ˆè·¯å¾‘ã€‚</span>'; return; }
      const base = rawBase();
      const full = encodeURI(base.url + rel);
      let type = typeEl.value;
      const lowerRel = rel.toLowerCase();
      if(lowerRel.endsWith('.srt')) { type='srt'; typeEl.value='srt'; }
      else if(lowerRel.endsWith('.csv')) { type='csv'; typeEl.value='csv'; }
      else if(lowerRel.endsWith('.docx')) { type='docx'; typeEl.value='docx'; }

      statusEl.textContent = `è¼‰å…¥ä¸­ï¼š${full}`; countsEl.textContent=''; resultEl.innerHTML='';
      try{
        if(type==='docx') await loadDocx(full);
        else await loadTextFile(full, type);
        const ghUrl = `https://github.com/${base.o}/${base.r}/blob/${base.b}/${rel}`;
        statusEl.innerHTML = `è¼‰å…¥å®Œæˆï¼š<a href="${full}" target="_blank" rel="noopener">Raw</a> Â· <a href="${ghUrl}" target="_blank" rel="noopener">GitHub</a>`;
        doSearch();
      }catch(err){
        statusEl.innerHTML = `<span class=\"error\">è¼‰å…¥å¤±æ•—ï¼š${escapeHtml(err.message||String(err))}</span>`;
      }
    }

    async function loadTextFile(url, type){
      const res = await fetch(url); if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      if(type==='srt'){ lastType='srt'; srtEntries=parseSrt(text); renderSrt(srtEntries); }
      else if(type==='csv'){ lastType='csv'; csvData=parseCsv(text); renderCsv(csvData.header, csvData.rows); }
    }

    async function loadDocx(url){
      const res = await fetch(url); if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const arrayBuffer = await res.arrayBuffer();
      const { value: html } = await window.mammoth.convertToHtml({ arrayBuffer });
      lastType='docx'; docxHtmlOriginal = `<div class=\"docx-content\">${html}</div>`; resultEl.innerHTML = docxHtmlOriginal;
    }

    function parseSrt(text){
      const norm = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
      const blocks = norm.split(/\n{2,}/);
      const entries=[];
      for(const block of blocks){
        const lines = block.trim().split("\n"); if(lines.length<1) continue;
        let index = lines[0].trim(); let timeLine=""; let textLines=[];
        if(/^\d+$/.test(index) && lines.length>=2){ timeLine=lines[1].trim(); textLines=lines.slice(2); }
        else { index=""; timeLine=lines[0].trim(); textLines=lines.slice(1); }
        let start="", end=""; const m=timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/); if(m){ start=m[1]; end=m[2]; }
        entries.push({ index, start, end, text: textLines.join("\n") });
      }
      return entries;
    }
    function renderSrt(entries, queryRegex){
      let html = "<table><thead><tr><th>#</th><th>Start</th><th>End</th><th>Text</th></tr></thead><tbody>";
      for(const e of entries){
        html += "<tr>"+
          `<td>${escapeHtml(e.index||"")}</td>`+
          `<td>${escapeHtml(e.start)}</td>`+
          `<td>${escapeHtml(e.end)}</td>`+
          `<td><pre>${queryRegex?highlightText(e.text, queryRegex):escapeHtml(e.text)}</pre></td>`+
          "</tr>";
      }
      html += "</tbody></table>"; resultEl.innerHTML = html;
    }

    function parseCsv(text){
      const norm = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
      const lines = norm.split("\n").filter(l=>l.trim()!=='');
      if(lines.length && lines[0].charCodeAt(0) === 65279){ lines[0] = lines[0].slice(1); }
      if(!lines.length) return {header:[],rows:[]};
      const header = splitCsvLine(lines[0]); const rows = lines.slice(1).map(splitCsvLine); return { header, rows };
    }
    function splitCsvLine(line){
      const out=[]; let cur=""; let inQ=false; for(let i=0;i<line.length;i++){
        const ch=line[i]; if(inQ){ if(ch==='"'){ if(i+1<line.length && line[i+1]=='"'){ cur+='"'; i++; } else inQ=false; } else cur+=ch; }
        else { if(ch==='"') inQ=true; else if(ch===','){ out.push(cur); cur=""; } else cur+=ch; }
      } out.push(cur); return out;
    }
    function renderCsv(header, rows, queryRegex){
      let html = "<table><thead><tr>" + header.map(h=>`<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
      for(const row of rows){ html += "<tr>" + header.map((_,i)=>{ const cell=row[i]??""; return `<td>${queryRegex?highlightText(cell, queryRegex):escapeHtml(cell)}</td>`; }).join("") + "</tr>"; }
      html += "</tbody></table>"; resultEl.innerHTML = html;
    }

    function clearDocxAndRestore(){ resultEl.innerHTML = docxHtmlOriginal; }
    function highlightInElement(root, regex){
      if(!regex) return 0; let count=0; const walker=document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null); const nodes=[]; while(walker.nextNode()) nodes.push(walker.currentNode);
      for(const node of nodes){ const text=node.nodeValue; if(!regex.test(text)){ regex.lastIndex=0; continue; } regex.lastIndex=0; const frag=document.createDocumentFragment(); let lastIndex=0; let m; while((m = regex.exec(text))){ if(m.index>lastIndex) frag.appendChild(document.createTextNode(text.slice(lastIndex, m.index))); const mark=document.createElement('mark'); mark.textContent=m[0]; frag.appendChild(mark); lastIndex = m.index + m[0].length; count++; if(!regex.global) break; } if(lastIndex<text.length) frag.appendChild(document.createTextNode(text.slice(lastIndex))); node.parentNode.replaceChild(frag, node); }
      return count;
    }

    function doSearch(){
      const query = qEl.value.trim(); const regex = buildRegex(query); countsEl.textContent='';
      if(lastType==='srt'){
        let data = srtEntries; if(regex && filterRowsEl.checked){ data = srtEntries.filter(e => regex.test(e.text)||regex.test(e.start)||regex.test(e.end)); if(regex) regex.lastIndex=0; }
        renderSrt(data, regex);
        if(regex){ let hit=0; for(const e of data){ const m=e.text.match(regex); if(m) hit += m.length; if(regex.global) regex.lastIndex=0; } countsEl.textContent=`å­—å¹•æ®µè½ï¼š${data.length} ï¼Œé«˜äº®æ¬¡æ•¸ï¼šç´„ ${hit}`; }
        else countsEl.textContent=`å­—å¹•æ®µè½ï¼š${data.length}`;
      }
      else if(lastType==='csv'){
        let rows = csvData.rows; if(regex && filterRowsEl.checked){ rows = csvData.rows.filter(r=> r.some(c => regex.test(String(c)))); if(regex) regex.lastIndex=0; }
        renderCsv(csvData.header, rows, regex);
        if(regex){ let hit=0; for(const r of rows){ for(const c of r){ const m=String(c).match(regex); if(m) hit += m.length; } if(regex.global) regex.lastIndex=0; } countsEl.textContent=`åˆ—æ•¸ï¼š${rows.length} ï¼Œé«˜äº®æ¬¡æ•¸ï¼šç´„ ${hit}`; }
        else countsEl.textContent=`åˆ—æ•¸ï¼š${rows.length}`;
      }
      else if(lastType==='docx'){
        clearDocxAndRestore(); const root = resultEl.firstElementChild || resultEl; const hits = regex ? highlightInElement(root, regex) : 0; countsEl.textContent = regex ? `é«˜äº®æ¬¡æ•¸ï¼šç´„ ${hits}` : '';
      }
    }
  </script>
</body>
</html>
