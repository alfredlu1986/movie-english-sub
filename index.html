<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Movie English Sub / CSV / DOCX Viewer + Search</title>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <style>
    :root{--bg:#f6f7fb;--card:#ffffff;--ink:#0f172a;--muted:#64748b;--brand:#2563eb;--brand-2:#1d4ed8;--line:#e2e8f0}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    .card{background:var(--card);border-radius:14px;box-shadow:0 10px 30px rgba(15,23,42,.06);padding:20px 22px}
    h1{font-size:20px;margin:0 0 8px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .grid{display:grid;gap:12px}
    @media(min-width:860px){.grid{grid-template-columns: 1.5fr 1fr}}
    label{display:block;font-weight:600;font-size:13px;margin:6px 0 4px}
    input,select,button{width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:14px}
    select{background:#fff}
    button{border:none;background:var(--brand);color:#fff;font-weight:700;cursor:pointer}
    button:hover{background:var(--brand-2)}
    .row{display:grid;grid-template-columns:1fr 1fr 1fr; gap:10px}
    .status{margin-top:10px;font-size:13px;color:var(--muted)}
    .status .error{color:#b91c1c;font-weight:700}
    .tools{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .tools > *{flex:1}
    .result{margin-top:16px;border-top:1px solid var(--line);padding-top:14px;overflow:auto}
    table{border-collapse:collapse;width:100%;font-size:14px}
    th,td{border:1px solid var(--line);padding:6px 8px;vertical-align:top}
    th{background:#f1f5f9}
    pre{white-space:pre-wrap;background:#0f172a;color:#e5e7eb;padding:8px;border-radius:8px;margin:0}
    code{background:#f1f5f9;padding:2px 4px;border-radius:6px}
    mark{padding:0 2px;border-radius:3px}
    .count{font-size:13px;color:var(--muted);margin-left:6px}
    .inline{display:flex;gap:10px;align-items:end}
    .inline > div{flex:1}
    .hint{font-size:12px;color:var(--muted)}
    .pill{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:999px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Movie English Sub / Words Viewer</h1>
      <p class="sub">從 <code>raw.githubusercontent.com</code> 讀取 <strong>.srt / .csv / .docx</strong>，支援<strong>關鍵字搜尋</strong>（高亮、可過濾列）。預設指向你的 repo：<span class="pill">alfredlu1986/movie-english-sub@main</span></p>

      <div class="grid">
        <div>
          <label>Owner</label>
          <input id="owner" value="alfredlu1986" />
        </div>
        <div>
          <label>Repo</label>
          <input id="repo" value="movie-english-sub" />
        </div>
        <div>
          <label>Branch</label>
          <input id="branch" value="main" />
        </div>
      </div>

      <div class="grid" style="margin-top:10px">
        <div>
          <label>檔案路徑（相對於 repo root，如 <code>EnWords.csv</code>、<code>1999/xxx.srt</code>、<code>docs/sample.docx</code>）</label>
          <input id="path" placeholder="例如：EnWords.csv 或 1999/movie.srt 或 docs/sample.docx" />
        </div>
        <div>
          <label>檔案類型</label>
          <select id="fileType">
            <option value="srt">SRT 字幕 (.srt)</option>
            <option value="csv">CSV (.csv)</option>
            <option value="docx">Word (.docx)</option>
          </select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="loadBtn">載入檔案</button>
        </div>
      </div>

      <div class="inline" style="margin-top:10px">
        <div>
          <label>關鍵字搜尋</label>
          <input id="q" placeholder="輸入關鍵字，Enter 搜尋" />
          <div class="hint">SRT / CSV 可選擇「只顯示符合」；DOCX 以全文高亮</div>
        </div>
        <div>
          <label>搜尋選項</label>
          <div class="tools">
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="matchCase"> 大小寫相符</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="wholeWord"> 全字比對</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="filterRows"> 只顯示符合（SRT/CSV）</label>
          </div>
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="tools">
            <button id="searchBtn">搜尋 / 高亮</button>
            <button id="clearBtn" style="background:#334155">清除</button>
          </div>
        </div>
      </div>

      <div class="status" id="status"></div>
      <div class="status" id="counts"></div>

      <div class="result" id="result"></div>
    </div>
  </div>

  <script>
    // ======== Helpers ========
    const $ = (id)=>document.getElementById(id);
    const ownerEl = $("owner");
    const repoEl = $("repo");
    const branchEl = $("branch");
    const pathEl = $("path");
    const typeEl = $("fileType");
    const loadBtn = $("loadBtn");
    const qEl = $("q");
    const matchCaseEl = $("matchCase");
    const wholeWordEl = $("wholeWord");
    const filterRowsEl = $("filterRows");
    const searchBtn = $("searchBtn");
    const clearBtn = $("clearBtn");
    const statusEl = $("status");
    const countsEl = $("counts");
    const resultEl = $("result");

    function rawBase(){
      const o = ownerEl.value.trim() || "alfredlu1986";
      const r = repoEl.value.trim() || "movie-english-sub";
      const b = branchEl.value.trim() || "main";
      return `https://raw.githubusercontent.com/${o}/${r}/${b}/`;
    }

    function escapeHtml(str){
      return String(str)
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;");
    }

    function escapeRegExp(str){
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function buildRegex(query){
      if(!query) return null;
      const src = wholeWordEl.checked ? `\\b${escapeRegExp(query)}\\b` : escapeRegExp(query);
      return new RegExp(src, matchCaseEl.checked ? "g" : "gi");
    }

    function highlightText(text, regex){
      if(!regex || !text) return escapeHtml(text);
      let out = "";
      let lastIndex = 0;
      const s = String(text);
      let m;
      while((m = regex.exec(s))){
        out += escapeHtml(s.slice(lastIndex, m.index));
        out += `<mark>${escapeHtml(m[0])}</mark>`;
        lastIndex = m.index + m[0].length;
        if(!regex.global) break; // avoid infinite
      }
      out += escapeHtml(s.slice(lastIndex));
      return out;
    }

    // ======== State ========
    let lastType = null; // 'srt' | 'csv' | 'docx'
    let srtEntries = []; // [{index,start,end,text}]
    let csvData = {header:[], rows:[]};
    let docxHtmlOriginal = ""; // original HTML for DOCX

    // ======== Load logic ========
    loadBtn.addEventListener("click", () => loadFile());
    qEl.addEventListener("keydown", (e)=>{ if(e.key==="Enter") doSearch(); });
    searchBtn.addEventListener("click", () => doSearch());
    clearBtn.addEventListener("click", () => { qEl.value=""; doSearch(); });

    async function loadFile(){
      const rel = pathEl.value.trim();
      if(!rel){ statusEl.innerHTML = '<span class="error">請輸入檔案路徑。</span>'; return; }
      const url = encodeURI(rawBase()+rel);
      let type = typeEl.value;
      const lowerRel = rel.toLowerCase();
      if(lowerRel.endsWith('.srt')) { type = 'srt'; typeEl.value='srt'; }
      else if(lowerRel.endsWith('.csv')) { type = 'csv'; typeEl.value='csv'; }
      else if(lowerRel.endsWith('.docx')) { type = 'docx'; typeEl.value='docx'; }
      statusEl.textContent = `載入中：${url}`;
      countsEl.textContent = "";
      resultEl.innerHTML = "";
      try{
        if(type === 'docx'){
          await loadDocx(url);
        }else{
          await loadTextFile(url, type);
        }
        statusEl.textContent = `載入完成：${url}`;
        doSearch();
      }catch(err){
        statusEl.innerHTML = `<span class="error">載入失敗：${escapeHtml(err.message||String(err))}</span>`;
      }
    }

    async function loadTextFile(url, type){
      const res = await fetch(url);
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      if(type==='srt'){
        lastType='srt';
        srtEntries = parseSrt(text);
        renderSrt(srtEntries);
      }else if(type==='csv'){
        lastType='csv';
        csvData = parseCsv(text);
        renderCsv(csvData.header, csvData.rows);
      }
    }

    async function loadDocx(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const arrayBuffer = await res.arrayBuffer();
      const { value: html } = await window.mammoth.convertToHtml({ arrayBuffer });
      lastType='docx';
      docxHtmlOriginal = `<div class="docx-content">${html}</div>`;
      resultEl.innerHTML = docxHtmlOriginal;
    }

    // ======== SRT ========
    function parseSrt(text){
      const norm = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
      const blocks = norm.split(/\n{2,}/);
      const entries=[];
      for(const block of blocks){
        const lines = block.trim().split("\n");
        if(lines.length<1) continue;
        let index = lines[0].trim();
        let timeLine = "";
        let textLines = [];
        if(/^\d+$/.test(index) && lines.length>=2){
          timeLine = lines[1].trim();
          textLines = lines.slice(2);
        }else{
          index = "";
          timeLine = lines[0].trim();
          textLines = lines.slice(1);
        }
        let start="", end="";
        const m = timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
        if(m){ start=m[1]; end=m[2]; }
        entries.push({ index, start, end, text: textLines.join("\n") });
      }
      return entries;
    }

    function renderSrt(entries, queryRegex){
      let html = "<table><thead><tr><th>#</th><th>Start</th><th>End</th><th>Text</th></tr></thead><tbody>";
      for(const e of entries){
        html += "<tr>"+
          `<td>${escapeHtml(e.index||"")}</td>`+
          `<td>${escapeHtml(e.start)}</td>`+
          `<td>${escapeHtml(e.end)}</td>`+
          `<td><pre>${queryRegex?highlightText(e.text, queryRegex):escapeHtml(e.text)}</pre></td>`+
          "</tr>`;
      }
      html += "</tbody></table>";
      resultEl.innerHTML = html;
    }

    // ======== CSV ========
    function parseCsv(text){
      const norm = text.replace(/
/g,"
").replace(//g,"
");
      const lines = norm.split("
").filter(l=>l.trim()!=="");
      if(lines.length && lines[0].charCodeAt(0) === 65279){ lines[0] = lines[0].slice(1); }
      if(!lines.length) return {header:[],rows:[]};
      const header = splitCsvLine(lines[0]);
      const rows = lines.slice(1).map(splitCsvLine);
      return { header, rows };
    }
      if(!lines.length) return {header:[],rows:[]};
      const header = splitCsvLine(lines[0]);
      const rows = lines.slice(1).map(splitCsvLine);
      return { header, rows };
    }

    function splitCsvLine(line){
      const out=[]; let cur=""; let inQ=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(inQ){
          if(ch==='"'){
            if(i+1<line.length && line[i+1]=='"'){ cur+='"'; i++; }
            else inQ=false;
          }else cur+=ch;
        }else{
          if(ch==='"') inQ=true;
          else if(ch===','){ out.push(cur); cur=""; }
          else cur+=ch;
        }
      }
      out.push(cur);
      return out;
    }

    function renderCsv(header, rows, queryRegex){
      let html = "<table><thead><tr>" + header.map(h=>`<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
      for(const row of rows){
        html += "<tr>" + header.map((_,i)=>{
          const cell = row[i] ?? "";
          return `<td>${queryRegex?highlightText(cell, queryRegex):escapeHtml(cell)}</td>`;
        }).join("") + "</tr>";
      }
      html += "</tbody></table>";
      resultEl.innerHTML = html;
    }

    // ======== DOCX highlight ========
    function clearDocxAndRestore(){
      resultEl.innerHTML = docxHtmlOriginal;
    }

    function highlightInElement(root, regex){
      if(!regex) return 0;
      let count = 0;
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      const textNodes = [];
      while(walker.nextNode()) textNodes.push(walker.currentNode);
      for(const node of textNodes){
        const text = node.nodeValue;
        if(!regex.test(text)) { regex.lastIndex = 0; continue; }
        regex.lastIndex = 0;
        const frag = document.createDocumentFragment();
        let lastIndex = 0; let m;
        while((m = regex.exec(text))){
          if(m.index>lastIndex) frag.appendChild(document.createTextNode(text.slice(lastIndex, m.index)));
          const mark = document.createElement('mark');
          mark.textContent = m[0];
          frag.appendChild(mark);
          lastIndex = m.index + m[0].length;
          count++;
          if(!regex.global) break;
        }
        if(lastIndex < text.length) frag.appendChild(document.createTextNode(text.slice(lastIndex)));
        node.parentNode.replaceChild(frag, node);
      }
      return count;
    }

    // ======== Search ========
    function doSearch(){
      const query = qEl.value.trim();
      const regex = buildRegex(query);
      countsEl.textContent = "";

      if(lastType==='srt'){
        let data = srtEntries;
        if(regex && filterRowsEl.checked){
          data = srtEntries.filter(e => regex.test(e.text) || regex.test(e.start) || regex.test(e.end));
          if(regex) regex.lastIndex = 0;
        }
        renderSrt(data, regex);
        if(regex){
          let hit=0; for(const e of data){ const m = e.text.match(regex); if(m) hit += m.length; if(regex.global) regex.lastIndex = 0; }
          countsEl.textContent = `字幕段落：${data.length} ，高亮次數：約 ${hit}`;
        }else{
          countsEl.textContent = `字幕段落：${data.length}`;
        }
      }

      else if(lastType==='csv'){
        let rows = csvData.rows;
        if(regex && filterRowsEl.checked){
          rows = csvData.rows.filter(r => r.some(c => regex.test(String(c))));
          if(regex) regex.lastIndex = 0;
        }
        renderCsv(csvData.header, rows, regex);
        if(regex){
          let hit=0; for(const r of rows){ for(const c of r){ const m = String(c).match(regex); if(m) hit += m.length; } if(regex.global) regex.lastIndex = 0; }
          countsEl.textContent = `列數：${rows.length} ，高亮次數：約 ${hit}`;
        }else{
          countsEl.textContent = `列數：${rows.length}`;
        }
      }

      else if(lastType==='docx'){
        clearDocxAndRestore();
        const root = resultEl.firstElementChild || resultEl; // .docx-content
        const hits = regex ? highlightInElement(root, regex) : 0;
        countsEl.textContent = regex ? `高亮次數：約 ${hits}` : '';
      }
    }
  </script>
</body>
</html>
